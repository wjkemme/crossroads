# Crossroads Project Planning

## Project Overview
- **Project Name**: Crossroads
- **Language**: C++
- **Code standard**: clean code (Robert C. Martin)
- **Build System**: cmake
- **Database**: ORM: sqlite_orm
- **Purpose**:
    - **Simple Traffic Generator**: This module is responsible for simulating the flow of vehicles approaching and entering a crossroad. It creates virtual traffic patterns, such as cars arriving at random intervals and from different directions, to mimic real-world conditions at an intersection.
    - **Basic Traffic Light Control Algorithm**: The application includes a straightforward logic for managing the traffic lights at the crossroad. This algorithm determines when each light turns green or red, coordinating the movement of vehicles through the intersection to ensure safety. This control algorithm is purely clock driven and does not consider any traffic information.
    - **Results Visualization on a Map**: The outcome of the simulation—such as vehicle movement, stops, and light changes—is displayed on a map within the application interface. This visualization allows users to observe how traffic flows and how the algorithm affects congestion and wait times at the crossroad.

## Basic Project Structure
crossroads/
├── main.cpp # Main application entry point
├── build/ # Compiled binary output directory
│ └── crossroads # Executable
├── .vscode/
│ ├── tasks.json # Build and run task configuration
│ └── launch.json # Debugger configuration
└── .copilot # Project planning file

## Features & Functionality
- 

## Build & Development Commands
- **Build & Run**: `Ctrl+Shift+B` (or `g++ main.cpp -o build/crossroads && ./build/crossroads`)
- **Debug**: `F5` (with gdb)

## Notes
- Dependencies required: g++, gdb
- **Constraints**: To ensure crossroad layouts are reusable and accessible, each configuration must be saved in a database. This approach not only provides flexibility for experimentation and deployment but also establishes a structured way to manage multiple intersection designs within the application.
- **Safety**: Before we start working on smarter control algorithms, we need to ensure that the crossroads are always in a safe state. Therefore, in between the control algorithm and the interface to the traffic lights, a safety checker will be added. The safety checker warrants the consistency of commands to the traffic lights. The safety checker implements a series of rules and rigorously checks that none of the rules are violated at any time.
- **Safety**: Before we start working on smarter control algorithms, we need to ensure that the crossroads are always in a safe state. Therefore, in between the control algorithm and the interface to the traffic lights, a safety checker will be added. The safety checker warrants the consistency of commands to the traffic lights. The safety checker implements a series of rules and rigorously checks that none of the rules are violated at any time.
- This approach ensures that conflicting signals—such as multiple directions showing green at the same time—are systematically prevented. The safety checker acts as a safeguard layer, monitoring all light changes and enforcing critical safety constraints regardless of the logic produced by the control algorithm. By introducing this component, the integrity and reliability of the intersection control system are significantly strengthened, reducing the risk of accidents caused by software errors or unforeseen circumstances.
- ORM: sqlite_orm
- QT message queing tussen server en client UI communicatie als dat mogelijk is en anders WebSocket/REST
- CMake

## Traffic light states and transitions
- Add `Orange` (amber) light state in addition to `Red` and `Green`.
- Allowed transitions per light: `Green -> Orange -> Red`, and `Red -> Green` only.
- The `Orange` state is always held for a fixed time period: **2 seconds**.
- **Crossing-light safety rule**: A light cannot transition to `Green` if the opposite (crossing) light is still `Green` or `Orange`.
  - North/South are opposites; East/West are opposites.
- The `SafetyChecker` will validate both safety invariants (no conflicting greens), transition validity (per-light transition rules and orange duration), and crossing-light constraints.


## Iteration: Different Control Algorithms
To enable smarter traffic management, the system needs to support multiple control algorithms and provide a mechanism for switching between them seamlessly. This begins with designing the application architecture so that different algorithms—such as the basic clock-driven control, the “null-control” (amber flashing mode), and more advanced logic—can coexist and be selected as needed. The ability to switch algorithms dynamically is crucial for both operational flexibility and safety.

Implementing a “null-control” mode, which causes all lights to flash amber, serves as a vital fallback. This mode should be triggered automatically if the safety checker detects any rule violation or inconsistency, ensuring the intersection never enters an unsafe or ambiguous state. When switching between algorithms, it is essential to introduce transitional logic that places all lights in a safe, well-defined state (such as all red or all flashing amber) before activating the next algorithm. This transitional period prevents conflicting signals and avoids illegal states, such as multiple greens in different directions.

Once robust algorithm management and safe switching are established, the system can evolve to include smarter algorithms that utilize input from traffic counters placed upstream in the lanes. These counters provide real-time data on approaching vehicles, enabling the control logic to optimize green light durations and reduce congestion proactively. By layering these enhancements, the intersection control system becomes both safer and more responsive to actual traffic conditions.

## Iteration: Key Performance Indicators
A simulation scenario includes three main components:
- The intersection itself, featuring its traffic lights and sensors
- The algorithm that manages control
- Configuration options for the traffic generators

## Iteration: Recording and Playback
The ability to record and replay scenarios is needed. This functionality allows for the preservation of specific simulation runs, facilitating thorough analysis and comparison of results. Playback capabilities ensure that scenarios can be revisited, helping refine algorithms and optimize intersection performance based on recorded data.

## Iteration: ORM (with a relational database)
The application becomes more and more dependent on its database. Traditional methods, accessing the database directly using query language statements such as SQL, ignore the fact that there is major commonality between the data structure in the database and the object model in the application. Enter Object Relation Mapping (ORM).
An Object-Relational Mapping (ORM) is a programming technique that creates a bridge between object-oriented programming languages and relational databases. An ORM is a layer of abstraction that converts data between incompatible type systems - specifically between your application's objects and your database's tables, rows, and columns.
Key Benefits:
- Abstraction of SQL: Write database operations using your programming language instead of SQL
Object-Oriented Interface: Interact with your database using familiar object-oriented patterns
- Reduced Boilerplate: Eliminate repetitive CRUD (Create, Read, Update, Delete) code
- Database Agnosticism: Switch database systems with minimal code changes
- Data Validation: Built-in validation before persisting data
ORMs provide a convenient way to work with databases while maintaining the object-oriented paradigm in your application code.
In this iteration, the app is to be refactored to use an ORM instead of direct access to the database.

## Iteration: Crossroads viewer and editor
To support applying the program to various road crossings, the application should incorporate a crossroads editor that enables users to design, modify, and select different intersection layouts. This editor will allow for the creation and customization of road crossing maps, which can be tailored to reflect real-world or hypothetical scenarios.

## Iteration: Decoupling of UI
Up till now, the UI has been an integral part of the application. Moving forward, we want to split the UI from the simulator and achieve the following:
- We want to close and restart the UI while the simulation keeps running. Ideally, we want to alter the UI without losing the state of the simulator.
- We want to instantiate multiple UIs, connected to the same simulation.
- We want to run the UI on a different computer than the simulation.
As usual, take care of security when connecting and running applications via a network.

## Iteration: Live Maps
To enhance the user experience, it is beneficial to load actual map data into the UI. Maps can be used from OpenSteetMaps or Google Maps.
This iteration is also suited to review and refine the traffic generators to make scenarios more realistic. E.g. trucks have different characteristics than passenger cars and thus behave differently in traffic.